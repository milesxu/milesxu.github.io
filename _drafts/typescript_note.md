---
---

# 基础类型

+ 只要两个类型的内部结构是兼容的，那么这两个类型（比如接口和类）就是兼容的。
+ 在类的 constructor 函数中的参数前面加上 public 关键字，就表示这些参数即为类的属性。
+ 基础类型：boolean、number、string。字符串使用单、双引号都可，而如果是模板字符串，则要用 ``，变量部分用 ${}。
+ 数组：number[]、Array<number>；元组：[..,..]；枚举：`enum Color {Red, Green, Blue}`。
+ 不知道的类型：any 类型。和已有的 JavaScript 合作时很重要。还可用 any 创建不同类型元素构成的数组，类似 Python 中的 list。
+ 还有函数的返回值可以为 void。关于空的类型：undefined 和 null。`string | null | undefined`。
+ 最好开着选项 --strictNullChecks。
+ never 类型表示永远不会出现的值的类型。比如某个函数返回值为 never 类型，其不可能返回，必然是抛出异常。
+ 类型断言有两种形式：`<string>someValue` 和 `someValue as string`。

# 变量声明

+ 和 C# 等语言不同， JavaScript 内的 var 变量不是代码块作用域，而是函数作用域。{} 并不会创建一个新的作用域。在域之内，对同一变量名使用多次 var 都得到同一个变量。
+ 因此 TypeScript（和 ES6）引入了 let 关键字，可以定义真正的块作用域变量。for 循环的局部变量是其一个典型应用。for 循环中如果用 var，则是同一个变量不断改变值，而如果用 let，则是每次迭代一个不同的副本。*尽可能使用 let*。在同一域内用 let 声明两次同一变量是错误。
+ 在嵌套的 for 循环中使用 let 声明两个同名变量会使外部的变量被覆盖，这有可能不会出错，但也不是好的方式。使得代码难于阅读。
+ const 有着和 let 一样的作用域规则，但是在作用域内只能被赋值一次。但要清楚的是，如果变量是对象，那么直接对其赋值只有一次，可是可以对其成员进行许多次赋值。
+ 对变量给的权力要尽可能的少，只要够用即可。
+ ES 2015 有了类似 Python 中的一行代码对多个变量赋值、交换赋值的功能，不过语法中要加中括号。如果加上 ... 前缀，则剩下的所有变量都赋值给有此前缀的变量。而如果没有前缀，且给定的值数组元素比变量数组元素多，则多出的部分忽略。
+ 用中括号是解构数组，如果用上大括号，就可以解构对象。为防止 JavaScript 将大括号解释为代码块，应该用小括号将解构赋值的两个大括号加上等号括起来。在变量名后面用冒号连接一个变量，效果等于给变量改名。
+ 变量名接问号表示变量可以是未定义的，而在解构赋值的等号左侧大括号内进行赋值，就是默认值。
+ 将一个数组放进另一个数组中，并加上 ... 前缀，就是将其元素逐个拷贝到另外的数组中。称为 spread。
+ 同理也有对象可以进行 spread，但是被加入的对象中如果有同名属性已有值，则后出现的那个值才是最终值。而且方法不会传递到新的对象中，会丢失。

# 接口

+ 可以直接在函数的参数中定义接口，如 `labelledObj: { label :string }`
+ 也可以预先定义一个接口，用 interface 关键字。接口的定义中也可以加入问号表示可选属性。这样的好处是仍然可以进行类型检查，访问不存在的属性（不是可选的）还是会报错。
+ 给属性声明的前面加上 readonly 关键字，可使属性只能被赋值一次。
+ TypeScript 定义了 ReadonlyArray<T> 类型，可酌情使用。
+ 变量用 const，属性用 readonly。
+ 在创建接口、类的实例时，如果有声明中不存在的属性，会报错。解决方式，一是用类型断言，二是在接口中加入形如 `[propName: string]: any;`。后者更好。最后一种方法是先建立对象，再传入对象参数，这样默认参数会保证不会报错。
+ 接口还可用来定义函数，就是没有名字的调用签名。
+ 接口还可以类似数组的类型，其成员形如 `[index: number]: string;`。数组的索引都是字符串，类似字典。还可定义 length 和 name 属性。同时也可以对数组类型用 readonly，则不能对索引形式赋值。
+ 可以用 implements 显式定义一个类继承自某个接口。
+ 类拥有两种类型成员：静态的和实例的。constructor 属于静态的，而接口的类型检查仅检查实例部分。
+ 接口中的函数声明前面放 new 关键字是对 constructor 的约束。要用另外的函数来检查静态，就是把对象、对象的静态函数的参数全部作为函数的参数，在其中进行调用。
+ 接口也可继承接口，用 extends 关键字。可继承多个接口。
+ 接口也可继承类，但是只得到其形状，而非实现。这种继承甚至会得到基类私有和受保护的成员。
